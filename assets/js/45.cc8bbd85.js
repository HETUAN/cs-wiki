(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{513:function(_,v,t){"use strict";t.r(v);var s=t(29),a=Object(s.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("p",[t("img",{attrs:{src:"https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/20201201223848.png",alt:""}})]),_._v(" "),t("h2",{attrs:{id:"_1-什么是贪心算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是贪心算法"}},[_._v("#")]),_._v(" 1. 什么是贪心算法")]),_._v(" "),t("p",[_._v("⭐ "),t("strong",[_._v("贪心算法总是做出在当前看来是最优的选择，也就是说，贪心算法并不从整体最优上考虑，所作的选择只是局部最优选择。")])]),_._v(" "),t("p",[t("u",[_._v("虽然贪心算法不是对所有问题都能得到整体最优解，但对很多问题都能产生整体最优解，或者最优解的很好的近似解。")])]),_._v(" "),t("img",{staticStyle:{zoom:"43%"},attrs:{src:"https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/20201105204101.png"}}),_._v(" "),t("h2",{attrs:{id:"_2-贪心算法的基本要素"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-贪心算法的基本要素"}},[_._v("#")]),_._v(" 2. 贪心算法的基本要素")]),_._v(" "),t("p",[_._v("动态规划问题的两个基本性质：")]),_._v(" "),t("ul",[t("li",[t("u",[_._v("最优子结构")])]),_._v(" "),t("li",[t("u",[_._v("子问题重叠性质")])])]),_._v(" "),t("p",[_._v("而贪心算法的两个基本性质：")]),_._v(" "),t("ul",[t("li",[t("p",[t("u",[_._v("最优子结构")])])]),_._v(" "),t("li",[t("p",[t("u",[t("strong",[_._v("贪心选择性质")])])]),_._v(" "),t("p",[_._v("贪心选择性质是指："),t("strong",[_._v("所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到")])])])]),_._v(" "),t("h2",{attrs:{id:"_3-贪心算法和动态规划算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-贪心算法和动态规划算法"}},[_._v("#")]),_._v(" 3. 贪心算法和动态规划算法")]),_._v(" "),t("p",[_._v("💡 "),t("strong",[_._v("贪心选择性质是贪心算法与动态规划算法的主要区别")]),_._v("：")]),_._v(" "),t("ul",[t("li",[t("u",[_._v("在动态规划算法中，每步所做的选择依赖于相关子问题的解，所以只有解决相关子问题后，才能做出选择")]),_._v("。")]),_._v(" "),t("li",[_._v("而在贪心算法中，仅在当前状态下做出最好选择，即局部最优选择，"),t("u",[_._v("再去解做出这个选择后产生的相应的子问题")]),_._v("。也就是说，"),t("strong",[_._v("贪心算法所做的贪心选择可以依赖过去所做过的选择，但绝不依赖将来所作的选择，也不依赖子问题的解")]),_._v("。")])]),_._v(" "),t("p",[_._v("⭐ 正是由于这种差别，"),t("strong",[_._v("动态规划算法是"),t("code",[_._v("自底向上")]),_._v("的，而贪心算法是"),t("code",[_._v("自顶向下")]),_._v("的")]),_._v("，以迭代的方式做出相继的贪心选择，"),t("strong",[_._v("每做一次贪心选择，就将所求问题简化为规模更小的子问题")]),_._v("。")]),_._v(" "),t("h2",{attrs:{id:"_4-贪心策略在图算法中的应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-贪心策略在图算法中的应用"}},[_._v("#")]),_._v(" 4. 贪心策略在图算法中的应用")]),_._v(" "),t("p",[_._v("几个重要的图算法基本都使用了贪心策略，详细可见【图】相关章节")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("单源最短路径："),t("code",[_._v("Dijkstra 算法")])])]),_._v(" "),t("li",[t("p",[_._v("最小生成树：")]),_._v(" "),t("ul",[t("li",[t("code",[_._v("Prim 算法")])]),_._v(" "),t("li",[t("code",[_._v("Kruskal 算法")])])])])])])}),[],!1,null,null,null);v.default=a.exports}}]);