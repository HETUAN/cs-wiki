(window.webpackJsonp=window.webpackJsonp||[]).push([[313],{781:function(t,s,_){"use strict";_.r(s);var v=_(29),n=Object(v.a)({},(function(){var t=this,s=t.$createElement,_=t._self._c||s;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"每张表都一定存在主键吗"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#每张表都一定存在主键吗"}},[t._v("#")]),t._v(" 每张表都一定存在主键吗？")]),t._v(" "),_("p",[t._v("关于这个问题，各位小伙伴们不妨先自己想一想，再往下寻找答案。")]),t._v(" "),_("br"),t._v(" "),_("p",[t._v("首先公布结论："),_("strong",[t._v("对于 InnoDB 存储引擎来说，每张表都一定有个主键（Primary Key）！")])]),t._v(" "),_("p",[t._v("让人非常遗憾的是，网络上至今仍然有非常多的文章是这样的描述：“一张表中必须有聚集索引，但不一定需要主键”。前半句是正确的，后半句是大错特错！")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/20210816215911.png",alt:""}})]),t._v(" "),_("p",[t._v("对于 InnoDB 存储引擎来说，表采用的存储方式称为"),_("strong",[t._v("索引组织表（index organizedtable）")]),t._v("，也即"),_("strong",[t._v("表都是根据主键的顺序来进行组织存放的")]),t._v("。如果主键都没有，表怎么存？")]),t._v(" "),_("p",[t._v("那下面这段没定义主键的建表语句是正确的吗？")]),t._v(" "),_("div",{staticClass:"language-sql extra-class"},[_("pre",{pre:!0,attrs:{class:"language-sql"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("CREATE")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("TABLE")]),t._v(" test"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n\ta "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("INT")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("NOT")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("NULL")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\tb "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("INT")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("NULL")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\tc "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("INT")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("NOT")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("NULL")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\td "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("INT")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("NOT")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("NULL")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\t"),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("UNIQUE")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("KEY")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("b"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\t"),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("UNIQUE")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("KEY")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("d"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\t"),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("UNIQUE")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("KEY")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("c"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),_("p",[t._v("当然是没有任何问题的。")]),t._v(" "),_("p",[t._v("因为 "),_("strong",[t._v("不显示定义主键 != 没有主键")]),t._v("。")]),t._v(" "),_("p",[t._v("如果在创建表时没有显式地定义主键，InnoDB 存储引擎会按如下方式选择或创建主键：")]),t._v(" "),_("ul",[_("li",[t._v("首先判断表中是否有"),_("strong",[t._v("非空")]),t._v("的"),_("strong",[t._v("唯一")]),t._v("索引（Unique NOT NULL），如果有，则该列即为主键")]),t._v(" "),_("li",[t._v("如果不符合上述条件，InnoDB 存储引擎自动创建一个 6 字节大小的指针 "),_("code",[t._v("_rowid")]),t._v(" 作为主键")])]),t._v(" "),_("p",[t._v("那"),_("strong",[t._v("如果表中有多个非空唯一索引时怎么办呢？")]),t._v(" InnoDB 存储引擎将选择建表时"),_("strong",[t._v("第一个")]),t._v("定义的"),_("strong",[t._v("非空唯一索引")]),t._v("为主键。需要注意的是！主键的选择根据的是非空唯一索引定义的顺序，而不是建表时列的顺序。")]),t._v(" "),_("p",[t._v("比如上面那段代码，有 a、b、c、d 四个列，b、c、d 三列上都有唯一索引。不过 b 列不是非空的，所以不可能成为主键了。而 d 列首先被定义为非空的唯一索引，所以 InnoDB 存储引擎将其视为主键。")]),t._v(" "),_("h2",{attrs:{id:"b-树索引总览"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#b-树索引总览"}},[t._v("#")]),t._v(" B+ 树索引总览")]),t._v(" "),_("p",[t._v("InnoDB 存储引擎支持以下几种常见的索引：")]),t._v(" "),_("ul",[_("li",[t._v("B+ 树索引")]),t._v(" "),_("li",[t._v("全文索引")]),t._v(" "),_("li",[t._v("哈希索引")])]),t._v(" "),_("p",[t._v("所谓哈希索引也就是得益于哈希算法的快速查找特性，不过哈希索引的致命缺点就是无法范围查询。并且 InnoDB 中哈希索引是自适应的，也就是说 InnoDB 存储引擎会根据表的使用情况自动为表生成哈希索引，"),_("strong",[t._v("不能人为干预是否在一张表中生成哈希索引")]),t._v("。")]),t._v(" "),_("p",[t._v("全文索引本文先暂且不做赘述。")]),t._v(" "),_("p",[t._v("再来看 B+ 树索引，"),_("strong",[t._v("B+ 树索引的本质就是 B+ 树在数据库中的实现")]),t._v("，它是目前关系型数据库系统中查找最为常用的索引。")]),t._v(" "),_("p",[t._v("关于 B+ 树的数据结构我就不详细说了，B 代表平衡（Balance），而不是二叉（Binary），B+ 树是从最早的平衡二叉树演化而来的，但是 B+ 树不是一个二叉树。")]),t._v(" "),_("p",[t._v("简单介绍下："),_("strong",[t._v("B+ 树是为磁盘或其他直接存取辅助设备设计的一种平衡查找树。在 B+ 树中，所有记录节点都是按键值的大小顺序存放在同一层的叶子节点上，各叶子节点之间通过双向链表进行连接。")])]),t._v(" "),_("p",[t._v("也就是说，"),_("u",[t._v("B+ 树的叶子节点存储真正的记录，而非叶子节点的存在是为了更快速的找到对应记录所在的叶子节点")]),t._v("。如下图是一个高度为 2 的 B+ 树：")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://staticcdn1-5.umiwi.com/epms_ebook/197b3be3529a45459e75524b83f91090.jpg?x-oss-process=image/resize,w_1280,m_lfit",alt:""}})]),t._v(" "),_("p",[t._v("另外，需要注意的是，"),_("strong",[t._v("B+ 树索引并不能找到一个给定键值的具体“行”！B+ 树索引能找到的只是被查找数据行所在的“页”。然后数据库通过把页读入到内存，再在内存中进行查找，最后得到要查找的数据")]),t._v("。")]),t._v(" "),_("p",[t._v("肯定有些小伙伴会懵逼了，“页” 又是什么东西？")]),t._v(" "),_("p",[t._v("这就得说到 InnoDB 存储引擎的逻辑存储结构。")]),t._v(" "),_("p",[t._v("InnoDB 存储引擎中，所有数据都被逻辑地存放在一个空间中，称之为 "),_("strong",[t._v("表空间（tablespace）")]),t._v("，也就是说我们常说的表，可以看作是 InnoDB 存储引擎逻辑结构的最高层。表空间又由 "),_("strong",[t._v("段（segment）")]),t._v("、"),_("strong",[t._v("区（extent）")]),t._v("、"),_("strong",[t._v("页（page）")]),t._v(" 组成（页有时也称为块 block）。如下图：")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://staticcdn1-5.umiwi.com/epms_ebook/477cdbf69b6e1c07fb775806fb6dfd38.jpg?x-oss-process=image/resize,w_1280,m_lfit",alt:""}})]),t._v(" "),_("p",[_("strong",[t._v("页是 InnoDB 磁盘管理的最小单位")]),t._v("，在 InnoDB 存储引擎中，默认每个页的大小为 16KB。而页里面存放的东西就是一行一行的记录。")]),t._v(" "),_("br"),t._v(" "),_("p",[t._v("我们接下来要说的 "),_("strong",[t._v("聚集索引（clustered inex）和辅助索引（secondary index）其实都是一种 B+ 树索引")]),t._v("。也就是说不管是聚集索引还是辅助索引，其内部都是 B+树，即高度平衡的，叶子节点存放着所有的数据。（需要注意的是，索引是存储引擎负责实现的，因此不是所有的存储引擎都支持聚簇索引）")]),t._v(" "),_("p",[_("strong",[t._v("聚集索引与辅助索引不同之处就是，叶子节点存放的是否是一整行的信息")]),t._v("。下文我们会详细解释。")]),t._v(" "),_("h2",{attrs:{id:"主键和聚集索引的关系"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#主键和聚集索引的关系"}},[t._v("#")]),t._v(" 主键和聚集索引的关系")]),t._v(" "),_("p",[t._v("先来看聚集索引，上面我们说过，InnoDB 存储引擎表是索引组织表结构，即表中数据都是按照主键顺序进行存放的。而"),_("strong",[t._v("聚集索引就是按照每张表的主键构造一棵 B+ 树，同时叶子节点中存放的即为表中一行一行的数据")]),t._v("，所以聚集索引的叶子节点也被称为数据节点。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://staticcdn1-5.umiwi.com/epms_ebook/48817f590bec4d0f53b569922a543d12.jpg?x-oss-process=image/resize,w_1280,m_lfit",alt:"聚簇索引的数据分布"}})]),t._v(" "),_("p",[t._v("也就是说，"),_("strong",[t._v("聚集索引能够在 B+ 树索引的叶子节点上直接找到数据")]),t._v("。并且由于定义了数据的逻辑顺序，查询优化器能够快速发现到底是哪一段范围的数据页需要扫描。比如用户需要查询一张用户表，查询最后注册的 10 位用户，由于 B+ 树索引的叶子节点是基于双向链表的，所以用户可以快速找到最后一个数据页，并取出 10 条记录。这也就是为什么大部分情况下查询优化器倾向于采用聚集索引了。")]),t._v(" "),_("p",[t._v("可以这么说：在聚集索引中，"),_("strong",[t._v("索引即数据，数据即索引")]),t._v("。")]),t._v(" "),_("br"),t._v(" "),_("p",[t._v("另外，由于数据页只能按照一棵 B+ 树进行查找排序，或者说无法同时把数据行存放在两个不同的地方，所以"),_("strong",[t._v("每张表只能拥有一个聚集索引")]),t._v("。")]),t._v(" "),_("p",[t._v("讲了这么多，好像还没讲到主键和聚集索引有啥区别。一张表只能有一个主键，并且也只能有一个聚集索引，聚集索引还是按照主键来构建的，那这种种迹象不都表明主键就是聚集索引？")]),t._v(" "),_("p",[t._v("事实上，"),_("strong",[t._v("主键和索引就不是一个层次的东西！")])]),t._v(" "),_("p",[t._v("主键是一种约束，这个约束用来强制表的实体完整性，一个表中只能有一个主键约束，并且主键约束中的列值必须是非空且唯一的。")]),t._v(" "),_("p",[t._v("而聚集索引它作为一种索引，其目的不是为了约束啥，而是为了对数据行进行排序以提高查询的效率，换句话说它决定的是数据库的物理存储结构。")]),t._v(" "),_("p",[t._v("⭐ 形象点说，一个没加聚集索引的表，它的数据是一行一行 "),_("strong",[t._v("无序")]),t._v(" 地存放在磁盘存储器上的。而如果给表添加了聚集索引，那么表在磁盘上的存储结构就由一行一行排列的结构转变成了 "),_("strong",[t._v("树状结构")]),t._v("，也就是 "),_("strong",[t._v("B+ 树结构")]),t._v("，换句话说，就是整个表就变成了一个索引，也就是上面提到的 “索引即数据，数据即索引”。")]),t._v(" "),_("p",[t._v("而至于 “主键就是索引” 这种观点的由来，是因为：InnoDB 存储引擎中，每张表都一定存在主键（显示或隐式），而聚集索引依赖于主键的建立，所以如果没有强制指定使用非聚集索引，InnoDB 在创建主键的同时会建立一个唯一的聚集索引（也有些文章称之为 "),_("strong",[t._v("主键索引")]),t._v("）。")]),t._v(" "),_("p",[t._v("所以，不要说 “主键就是聚集索引”，应该这样说：“"),_("strong",[t._v("聚集索引一般都是加在主键上的")]),t._v("”。")]),t._v(" "),_("h2",{attrs:{id:"聚集索引和辅助索引的关系"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#聚集索引和辅助索引的关系"}},[t._v("#")]),t._v(" 聚集索引和辅助索引的关系")]),t._v(" "),_("p",[_("strong",[t._v("辅助索引（Secondary Index）也称为 非聚集索引、二级索引")]),t._v("。其和聚集索引的最大区别就在于，辅助索引的叶子节点并不包含行记录的全部数据。")]),t._v(" "),_("p",[t._v("简单来说，一行记录我们可以用 “主键 + 其他数据” 这样的组合来标识，聚集索引中的叶子节点存储的就是这一整个组合，而非聚集索引中的叶子节点只存储了这个组合中的主键，那其他数据我怎么获得呢？")]),t._v(" "),_("p",[t._v("非聚集索引的叶子节点说还包含了一个 "),_("strong",[t._v("书签（bookmark）")]),t._v("，该书签用来告诉 InnoDB 存储引擎哪里可以找到与索引相对应的行数据。")]),t._v(" "),_("p",[t._v("那各位不妨想一想，行数据存储在哪里呢？")]),t._v(" "),_("p",[t._v("没错，上文说过，聚集索引中的叶子节点中存放的就是表中一行一行的数据，"),_("strong",[t._v("所以 InnoDB 存储引擎的辅助索引中的书签其实就是相应行数据的聚集索引键")]),t._v("。")]),t._v(" "),_("p",[t._v("也就是说，"),_("strong",[t._v("辅助索引的叶子节点包含的是：每行数据的辅助索引键 + 该行数据对应的聚集索引键")]),t._v("。")]),t._v(" "),_("p",[t._v("当通过辅助索引来寻找数据时，InnoDB 存储引擎会先遍历辅助索引的 B+ 树，通过叶子节点获得某个辅助索引键对应的聚集索引键，然后再通过聚集索引来找到一个完整的行记录。")]),t._v(" "),_("p",[t._v("举个例子，如果在一棵高度为 3 的辅助索引树中查找数据，那需要对这棵辅助索引树遍历 3 次找到指定聚集索引键，如果聚集索引树的高度同样为 3，那么还需要对聚集索引树进行 3 次查找，最终找到一个完整的行数据所在的页，因此一共需要 6 次逻辑 IO 访问以得到最终的一个数据页。")]),t._v(" "),_("p",[t._v("另外，很显然的是，辅助索引的存在并不影响数据在聚集索引中的组织，因此"),_("strong",[t._v("每张表上可以有多个辅助索引")]),t._v("。")])])}),[],!1,null,null,null);s.default=n.exports}}]);