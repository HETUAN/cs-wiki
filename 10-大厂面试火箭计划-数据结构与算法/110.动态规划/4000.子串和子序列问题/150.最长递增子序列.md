---
title: 最长递增子序列
---

## 📃 题目描述

题目链接：[300. 最长递增子序列 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

给你一个整数数组 nums，找到其中最长严格递增子序列的长度。

子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。


示例 1：

```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

示例 2：

```
输入：nums = [0,1,0,3,2,3]
输出：4
```

示例 3：

```
输入：nums = [7,7,7,7,7,7,7]
输出：1
```

## 🔔 解题思路

**dp[i] 表示以 nums[i] 结尾的最长递增子序列的长度**（下标 i 之前并且包括下标 i 的最长上升子序列的长度）

该问题符合最优子结构性质。**以第 `i` 个数结尾的最长递增序列，一定包含以第 `j` 个数（`j < i`）结尾的最长递增序列**

也就是说：以 nums[i] 结尾的的最长升序子序列长度等于以 nums[j] 结尾（j < i）的的最长升序子序列 +1 的最大值

对于一个数(nums[i])，有两个选择，加入这个递增子序列还是不加入：

- if (nums[i] > nums[j]) -> dp[i] = Math.max(dp[i], dp[j] + 1);

base case：

以 nums[i] 结尾的递增子序列至少都是包含自身的，所以初始化为 1


```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }

        int[] dp = new int[nums.length];

        // base case
        Arrays.fill(dp, 1);
		
        // 最终结果
        int res = dp[0];
        
        // loop
        for (int i = 1; i < dp.length; i ++) {
            for (int j = 0; j < i; j ++) {
                if (nums[i] > nums[j]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }

                // 取最大值
                res = Math.max(dp[i], res);
            }
        }

        return res;
    }
}
```

> 注意这里的 res 初始化为 1，因为第一次进入 res = Math.max(dp[i], res); 这行代码的时候，想比较的就是 dp[1] 和 dp[0]，所以 res 初始化为 dp[0] 的值就行了

## 💥 复杂度分析

- 空间复杂度：
- 时间复杂度：

