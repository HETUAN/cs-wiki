---
date: 2022-03-20 11:54:00
permalink: /pages/3ff543/
title: 垃圾收集算法
---
## “标记-清除算法”

最基础的垃圾收集算法是“标记-清除”（Mark-Sweep）算法，在1960年由Lisp之父John McCarthy所提出。

**算法分为“标记”和“清除”两个阶段**：

1. 首先标记出所有需要回收的对象
2. 在标记完成后，统一回收掉所有被标记的对象

也可以反过来，标记存活的对象，统一回收所有未被标记的对象。

标记过程就是对象是否属于垃圾的判定过程，这在前一节讲述垃圾对象标记判定算法时其实已经介绍过了。 之所以说它是最基础的收集算法，是因为**后续的收集算法大多都是以标记-清除算法为基础，对其缺点进行改进而得到的**。

它的主要缺点有两个：

1. 第一个是执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低；
2. 第二个是内存空间的碎片化问题，**标记、清除之后会产生大量不连续的内存碎片**，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

标记-清除算法的执行过程如图

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bef49811-0930-4bcf-95b4-256174d618d7/Untitled.png)

## “标记-复制算法”

标记-复制算法常被简称为复制算法。**为了解决标记-清除算法面对大量可回收对象时执行效率低的问题**，1969年Fenichel提出了一种称为**“半区复制”（Semispace Copying）**的垃圾收集算法：

**它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉**。

如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销，但**对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象**，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。

这样实现简单，运行高效，不过其缺陷也显而易见，**这种复制回收算法的代价是将可用内存缩小为了原来的一半，空间浪费未免太多了一点**。标记-复制算法的执行过程如图3-3所示。

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/800ccd38-9647-44d5-ba02-7ac82fff5e6f/Untitled.png)

**现在的商用Java虚拟机大多都优先采用了这种收集算法去回收新生代**

IBM公司曾有一项专门研究对新生代“朝生夕灭”的特点做了更量化的诠释——**新生代中的对象有98%熬不过第一轮收集。因此并不需要按照1∶1的比例来划分新生代的内存空间**。

在1989年，Andrew Appel针对具备“朝生夕灭”特点的对象，提出了一种更优化的半区复制分代策略，现在称为“**Appel式回收**”。HotSpot虚拟机的Serial、ParNew等新生代收集器均采用了这种策略来设计新生代的内存布局。

⭐ **Appel式回收的具体做法是把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，直接清空 Eden 和已用过的那块Survivor 空间，当然，在清空之前需要将存活对象复制到另一块 Survivor 中**。

这两块Survivor 空间也分别被称为 From Survivior 和 To Survivor，很显然，没经过一次新生代 GC，From Survivor 和 To Survivor 的身份就会互换。

<aside> 💡 简单理解，**Eden 和 From Survivor 其实就是新生代能够使用的真正内存，而 To Survivor 的存在是为了在清空新生代空间时提供一个地方用来存放仍然存活的对象**


</aside>

HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也即每次新生代中可用内存空间为整个新生代容量的90%（Eden的80%加上一个Survivor的10%），只有一个Survivor空间，即10%的新生代是会被“浪费”的。

当然，98%的对象可被回收仅仅是“普通场景”下测得的数据，任何人都没有办法百分百保证每次回收都只有不多于10%的对象存活，因此Appel式回收还有一个充当罕见情况的“**逃生门**”的安全设计，**当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保（Handle Promotion）**。

内存的分配担保：

- **如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象，这些对象便将通过分配担保机制直接进入老年代**，这对虚拟机来说就是安全的。关于对新生代进行分配担保的内容，在稍后的3.8.5节介绍垃圾收集器执行规则时还会再进行讲解

## “标记-整理算法”

**标记-复制算法在对象存活率较高时就要进行较多的复制操作，效率将会降低。更关键的是，如果不想浪费50%的空间，使用 Apple 式回收的话，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法**。

针对老年代对象的存亡特征，1974年Edward Lueders提出了另外一种有针对性的“标记-整理”（Mark-Compact）算法，**其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存**，“标记-整理”算法的示意图如图3-4所示。

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/54afda30-bbdb-4852-af75-66448e1a2627/Untitled.png)

标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的。**是否移动回收后的存活对象是一项优缺点并存的风险决策**

- **如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活区域，移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须全程暂停用户应用程序才能进行**，这就更加让使用者不得不小心翼翼地权衡其弊端了，像这样的停顿被最初的虚拟机设计者形象地描述为“`Stop The World`”。（移动存活对象时需要 STW，可达性分析 根节点枚举的时候也需要 STW）
- 但如果跟标记-清除算法那样完全不考虑移动和整理存活对象的话，弥散于堆中的存活对象导致的空间碎片化问题就只能依赖更为复杂的内存分配器和内存访问器来解决。譬如通过“分区空闲分配链表”来解决内存分配问题（计算机硬盘存储大文件就不要求物理连续的磁盘空间，能够在碎片化的硬盘上存储和访问就是通过硬盘分区表实现的）。内存的访问是用户程序最频繁的操作，甚至都没有之一，假如在这个环节上增加了额外的负担，势必会直接影响应用程序的吞吐量。

基于以上两点，是否移动对象都存在弊端，移动则内存回收时会更复杂，不移动则内存分配时会更复杂。**从垃圾收集的停顿时间来看，不移动对象（标记-清除）停顿时间会更短，甚至可以不需要停顿，但是从整个程序的吞吐量来看，移动对象（标记-整理）会更划算**。

此语境中，吞吐量的实质是赋值器（Mutator，可以理解为使用垃圾收集的用户程序，本书为便于理解，多数地方用“用户程序”或“用户线程”代替）与收集器的效率总和。即使不移动对象会使得收集器的效率提升一些，但因内存分配和访问相比垃圾收集频率要高得多，这部分的耗时增加，总吞吐量仍然是下降的。

**HotSpot 虚拟机里面关注吞吐量的老年代收集器 Parallel Old 是基于标记-整理算法的，而关注延迟的老年代收集器 CMS 收集器则是基于标记-清除算法的，这也从侧面印证这点**。

另外，还有一种“和稀泥式”解决方案可以不在内存分配和访问上增加太大额外负担，做法是**让虚拟机平时多数时间都采用标记-清除算法，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经大到影响对象分配时，再采用标记-整理算法收集一次，以获得规整的内存空间**。前面提到的**基于标记-清除算法的 CMS 收集器面临空间碎片过多时采用的就是这种处理办法**