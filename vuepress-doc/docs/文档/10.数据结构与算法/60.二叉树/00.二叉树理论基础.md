---
title: 二叉树理论基础
date: 2021-11-03 17:00:33
permalink: /binarytree
---

## 树的种类

- 二叉排序树（二叉查找树）
- 平衡二叉树
- 完全二叉树
- 哈夫曼树
- 红黑树

![](https://gitee.com/veal98/images/raw/master/img/20201118103034.png)

## 如何构造一棵二叉树

二叉树节点的定义如下：

```java
// 定义二叉树节点
static class TreeNode {
    private int val;
    private TreeNode left;
    private TreeNode right;

    public TreeNode (int val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}
```

下面这套构建二叉树的代码对应如下的输入格式：

第一行输入两个整数 n 和 root，n 表示二叉树的总节点个数，root 表示二叉树的根节点。

以下 n 行每行三个整数 fa，lch，rch，表示 fa 的左儿子为 lch，右儿子为 rch。(如果 lch 为 0 则表示 fa 没有左儿子，rch 同理)

示例

```
输入
3 1
1 2 3
2 0 0
3 0 0
```

<img src="https://gitee.com/veal98/images/raw/master/img/20220305103621.png" style="zoom:50%;" />

```
输入
1 2 3
2 4 5
4 0 0
5 0 0
3 6 7
6 0 0
```

【具体代码】：

```java
// 构造二叉树
private static TreeNode createTree(Scanner sc) {
    String[] values = sc.nextLine().split(" ");
    if (values.length < 3) {
        return null;
    }

    int value = Integer.parseInt(values[0]);
    int left = Integer.parseInt(values[1]);
    int right = Integer.parseInt(values[2]);

    TreeNode root = new TreeNode(value);
    if (left != 0) {
        root.left = createTree(sc);
    }
    if (right != 0) {
        root.right = createTree(sc);
    }

    return root;
}

public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    sc.nextLine(); // 第一行没啥用
    TreeNode root = createTree(sc);
}
```

## 二叉树的四种遍历方法

二叉树主要有两种遍历方式（共四种遍历方法）：

1. **深度优先遍历 DFS**：先往深走，遇到叶子节点再往回走（利用**栈**先进后出的特性）
   - 前序遍历（递归法 / 迭代法）
   - 中序遍历（递归法 / 迭代法）
   - 后序遍历（递归法 / 迭代法）
2. **广度优先遍历 BFS**：一层一层的去遍历（利用**队列**先进先出的特性）
   - 层次遍历（迭代法）

事实上，这两种遍历是图论中最基本的两种遍历方式，后面在介绍图的时候 还会讲到

另外，这几种遍历方法的时间复杂度都是 O(N)，因为每个节点都被顺序遍历了一次嘛；而空间复杂度取决于树的高度，当树退化为单链表的时候，空间复杂度降到 O(LogN)，正常情况下，空间复杂度都是 O(LogN)

### 前序遍历

题目链接：[144. 二叉树的前序遍历 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg)

```
输入：root = [1,null,2,3]
输出：[1,2,3]
```

- **递归**
  
  ```java
  public List<Integer> preorderTraversal(TreeNode root) {
      List<Integer> res = new ArrayList<>();
  
      if (root == null) {
          return res;
      }
  
      res.add(root.val);
      preorderTraversal(root.left);
      preorderTraversal(root.right);
  
      return res;
  }
  ```

- **迭代**
  
  ```java
  public List<Integer> preorderTraversal2(TreeNode root) {
      List<Integer> res = new ArrayList<>();
  
      if (root == null) {
          return res;
      }
  
      // 辅助栈
      Stack<TreeNode> stack = new Stack<>();
      // 工作指针
      TreeNode cur = root;
  
      while (!stack.isEmpty() || cur != null) {
          if (cur != null) {
              stack.push(cur);
              // 根
              res.add(cur.val);
              // 左
              cur = cur.left;
          } else {
              cur =  stack.pop();
              // 右
              cur = cur.right;
          }
      }
  
      return res;
  }
  ```

### 中序遍历

题目链接：[94. 二叉树的中序遍历 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

- **递归**
  
  ```java
  // 递归
  public List<Integer> inorderTraversal(TreeNode root) {
      List<Integer> res = new ArrayList<>();
  
      if (root == null) {
          return res;
      }
  
      inorderTraversal(root.left);
      res.add(root.val);
      inorderTraversal(root.right);
  
      return res;
  }
  ```

- **迭代**
  
  ```java
  // 迭代
  public List<Integer> inorderTraversal2(TreeNode root) {
      List<Integer> res = new ArrayList<>();
  
      if (root == null) {
          return res;
      }
  
      // 辅助栈
      Stack<TreeNode> stack = new Stack<>();
      // 工作指针
      TreeNode cur = root;
  
      while (!stack.isEmpty() || cur != null) {
          if (cur != null) {
              stack.push(cur);
              // 左
              cur = cur.left;
          } else {
              // 根
              cur = stack.pop();
              res.add(cur.val);
              // 右
              cur = cur.right;
          }
      }
  
      return res;
  }
  ```

### 后序遍历

题目链接：[145. 二叉树的后序遍历 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

- **递归**
  
  ```java
  // 递归
  public List<Integer> postorderTraversal(TreeNode root) {
      List<Integer> res = new ArrayList<>();
  
      if (root == null) {
          return res;
      }
  
      res.add(root.val);
      postorderTraversal(root.left);
      postorderTraversal(root.right);
  
      return res;
  }
  ```

- **迭代**
  
  ```java
  // 迭代
  public List<Integer> postorderTraversal2(TreeNode root) {
      List<Integer> res = new ArrayList<>();
  
      if (root == null) {
          return res;
      }
  
      // 辅助栈
      Stack<TreeNode> stack = new Stack<>();
      // 工作指针
      TreeNode cur = root;
      // 最近访问过的节点
      TreeNode visited = null;
  
      while (!stack.isEmpty() || cur != null) {
          if (cur != null) {
              stack.push(cur);
              // 左
              cur = cur.left;
          } else {
              cur = stack.peek();
              // 右
              if (cur.right != null && cur.right != visited) {
                  cur = cur.right;
                  stack.push(cur);
                  // 再走到最左
                  cur = cur.left;
              } else {
                  cur = stack.pop();
                  // 根
                  res.add(cur.val);
  
                  // 更新最近访问过的节点
                  visited = cur;
                  cur = null;
              }
          }
      }
  
      return res;
  }
  ```

### 层次遍历

题目链接：[102. 二叉树的层序遍历 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

给你一个二叉树，请你返回其按 层序遍历 得到的节点值（即逐层地，从左到右访问所有节点）。

示例：

```
二叉树：[3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7

返回其层序遍历结果：
[
  [3],
  [9,20],
  [15,7]
]
```

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>(); // 存储遍历结果
        Queue<TreeNode> queue = new LinkedList<>(); // 辅助队列

        if (root == null) {
            return res;
        }

        queue.offer(root); // 根节点入队
        while (!queue.isEmpty()) {
            List<Integer> line = new ArrayList<>(); // 存储每层的节点
            int sz = queue.size();
            for (int i = 0; i < sz; i ++) {
                TreeNode cur = queue.poll();
                line.add(cur.val);

                if (cur.left != null) {
                    queue.offer(cur.left);
                }
                if (cur.right != null) {
                    queue.offer(cur.right);
                }
            }
            res.add(line);
        }

        return res;
    }
}
```
