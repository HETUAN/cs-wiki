---
title: 图理论基础
date: 2022-03-14 17:00:33
permalink: /graph
---

## 图的表示

图可以分为有向图和无向图

![](https://gitee.com/veal98/images/raw/master/img/20220314104521.png)

通常，图可以用邻接表或邻接矩阵表示。

- 邻接表：**邻接表为图中的每个节点创建一个容器，第 i 个容器保存所有与第 i 个节点相邻的节点**。例如，上图中的有向图和无向图可以分别用下图（a）和（b）所示的邻接表表示：

  ![](https://gitee.com/veal98/images/raw/master/img/20220314104659.png)

- 邻接矩阵：如果一个图中有n个节点，那么它的邻接矩阵M的大小是n×n。如果节点i和节点j之间有一条边，那么 `M[i][j]` 等于 1；反之，如果节点i和节点j之间没有边，那么 `M[i][j]` 等于0

  ![](https://gitee.com/veal98/images/raw/master/img/20220314105515.png)

如果一个图是用邻接矩阵表示的，那么判断两个节点之间是否有边相连就非常简单，只需要判断矩阵中对应位置是1还是0即可，时间复杂度为O（1）。**但如果一个图中的节点数目非常大但比较稀疏（大部分节点之间没有边），那么邻接表的空间效率更高**。

例如，微信有数亿个用户，大部分用户只有几百个好友。可以用一个图表示微信用户的好友关系，每个用户是图中的一个节点，如果两个用户是好友那么他们的节点之间有一条边。

- 如果用邻接矩阵表示这个图，每个用户在矩阵中对应一行，每行有数亿个格子，而且绝大多数格子的值都是0。
- 如果用邻接表表示该图，那么一个用户有多少个好友，邻接表就只需要将多少个好友保存到他的好友列表中。

图还可以分为有权图和无权图。在有权图中，每条边都有一个数值权重，用来表示两个节点的某种关系，如两个节点的距离等。在无权图中所有的边都没有权重。

## 图的搜索

在图中搜索，如找出一条从起始节点到目标节点的路径或遍历所有节点，是与图相关的最重要的算法。

按照搜索顺序不同可以将搜索算法分为**广度优先搜索**和**深度优先搜索**。

### BFS

广度优先搜索系统地展开并检查图中的所有节点以找寻结果。

实现广度优先搜索算法需要一个先进先出的**队列**

- 搜索的第 1 步是把起始节点添加到队列中
- 接下来每次从队列中取出一个节点，然后**将与该节点相邻并且之前还没有到达过的节点添加到队列中**
- 重复这个过程，直到所有节点搜索完毕

> 和层序遍历差不多

例如，按照广度优先搜索的顺序从节点 1 开始搜索下图中的节点：节点1、节点2、节点3、节点4、节点5、节点6、节点7、节点 8 将依次被访问。

<img src="https://gitee.com/veal98/images/raw/master/img/20220314110021.png" style="zoom:50%;" />

### DFS

深度优先搜索算法沿着图中的边尽可能深入地搜索。

- 深度优先搜索访问图中的某个起始节点 v1 后，从节点v1 出发访问任一相邻并且尚未访问过的节点 v2，再从节点 v2 出发访问相邻并且尚未访问过的节点 v3，以此类推。
- 如果所有与某个节点 vi 相邻的节点都已经被访问，那么回到节点 vi 的前一个节点 vi-1，继续访问与节点 vi-1 相邻并且还没有访问过的节点。重复这个过程，直到所有节点都搜索完毕。

例如，按照深度优先搜索的顺序从节点 1 开始搜索上图中的节点，节点 1、节点 2、节点4、节点8、节点5、节点 3、节点 6、节点 7 将依次被访问。

> - 广度优先搜索能够保证在无权图中从某个起始节点出发用最短的距离到达目标节点。<u>在无权图中，两个节点的距离通常是连通两个节点的路径经过的节点的数目</u>。
>
>   所以，如果面试题要求在**无权图**中找出**两个节点之间的最短距离**，那么广度优先搜索可能是更合适的算法。（`看到 “最短” 就要想到 BFS`）
>
> - 深度优先搜索沿着相邻节点的边一直纵向搜索下去，因此很容易就能知道从起始节点到目标节点的路径所经过的所有节点。
>
>   所以，如果面试题要求找出**符合条件的路径**，那么深度优先搜索可能是更合适的算法。

### 解题小经验

树也可以看成图。实际上，树是一类特殊的图，树中一定不存在环。但图不一样，图中可能包含环。

当沿着图中的边搜索一个图时，一定要确保程序不会因为沿着环的边不断在环中搜索而陷入死循环。

避免死循环的办法是**记录已经搜索过的节点**，**在访问一个节点之前先判断该节点之前是否已经访问过，如果之前访问过那么这次就略过不再重复访问**。

⭐ 假设一个图有 v 个节点、e 条边。**不管是采用广度优先搜索还是深度优先搜索，每个节点都只会访问一次，并且会沿着每条边判断与某个节点相邻的节点是否已经访问过，因此时间复杂度是 $ O（v+e）$**。

## 拓扑排序

## 并查集